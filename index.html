<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>commonJS</title>
</head>
<body>
	<h2>定义</h2>
	<cite>
		CommonJS is a project with the goal of specifying an ecosystem for JavaScript outside the browser (for example, on the server or for native desktop applications).
	</cite>
	<br>
	<cite>
		CommonJS是一个以打造规范的Javascript代码生态圈为目标的项目，并且可以应用在除浏览器之外的各个方面（例如服务器或原生桌面应用程序）。
	</cite>
	<br>
	<p>
		简而言之，commonJS定义了一种<b>规范标准</b>，规定了模块的格式，使得不同开发者可以十分方便地直接使用其他人编写出来的模块，同时又不会有命名冲突等麻烦，最终来打造成一个实用的标准库。
		commonJS API也提供了一些普通的应用程序可以使用的API。
	</p>
	<p>
		用容易理解的方式表达，以往引用其他文件的方式为
		<div>"&lt;script src='要引用的文件.js'&gt;"</div>
		但这种方法会导致变量名重复的问题，例如A文件定义了一个length变量，B文件同样也定义了该变量，如果执行
		<div>"&lt;script src='A.js'&gt;"</div>
		<div>"&lt;script src='B.js'&gt;"</div>
		后来引用的B文件会覆盖了A文件定义的length变量，commonJS则解决了这个问题。
	</p>

	<h2>历史</h2>
	<p>
		2009年1月，Mozilla开创并将它命名为ServerJS。
	</p>
	<p>
		2009年8月，ServerJS重命名为CommonJS并公布了许多可应用的API。
	</p>
	<p>
		2009年Ryan Dahl写成的Node.js就是对CommonJS的一种实现。
	</p>

	<h2>原理</h2>
	<p>
		（以下实例在Node.js环境下运行）
	</p>
	<p>
		每个js文件本身有一个module对象（通过对Node提供的Module构造函数进行实例化得到），在模块中可以用使用module.exports来构建模块，我们可以创建一个文件对module进行输出，来查看module对象的所有属性。
	</p>
	<p>
		这里创建一个module_attributes.js文件，里面只写了一行代码
		<pre>console.log(module);</pre>
		运行结果：
		<pre>
Module {
  id: '.',
  exports: {},
  parent: null,
  filename: 'D:\\Git\\common-test\\js\\module_attributes.js',
  loaded: false,
  children: [],
  paths:
   [ 'D:\\Git\\common-test\\js\\node_modules',
     'D:\\Git\\common-test\\node_modules',
     'D:\\Git\\node_modules',
     'D:\\node_modules' ] }
		</pre>
		<div>id：模块的标识符</div>
		<div>exports：其他文件通过require命令调用当前模块后，返回的对象</div>
		<div>parent：调用当前模块的模块</div>
		<div>filename：当前模块的绝对路径</div>
		<div>loaded：当前模块是否已经加载</div>
		<div>children：当前模块调用的模块</div>
		<div>可以看到，module其实就是描述当前js文件的一个对象，也可以直接理解为module就是js文件自身。</div>
		<div>在调用其他模块时，只需要</div>
		<pre>require('要调用的模块')</pre>
		该命令会返回被调用模块的exports对象，也就是说可以先为该对象添加属性和方法，require后就可以直接使用被调用模块的exports对象的属性和方法。
		<div>例如，假设被调用的模块为add.js，功能为两数相加和，进行调用的模块为index.js</div>
		add.js代码
		<pre>
module.exports.add = function (a, b) {
	return a + b;
}
		</pre>
		index.js代码
		<pre>
var mod = require('./add.js');
var sum = mod.add(1, 2);
console.log(sum);
		</pre>
		<div>执行结果</div>
		<pre>3</pre>
		<div>运行index.js，执行require后会返回add.js里的exports对象，此时exports对象已经添加了add函数，于是我们可以开始使用该函数了。（require默认加载javascript文件，因此当加载的文件是js格式时，可以省略文件后缀）</div>
	</p>
	<p>
		<div>为了在模块内方便给module.exports对象添加属性和方法，每个模块还有一个exports变量，该变量其实就是module.exports的赋值，相当于在模块最前面运行了</div>
		<pre>var exports = module.exports</pre>
		<div>由于调用时返回的是module.exports而不是exports，因此不应该对exports进行赋值。</div>
		<div>动画演示</div>
	</p>
	<p>
		require采用的是同步、带缓存的加载。因此模块在第一次加载后，再次加载时会直接使用缓存而不用重复加载。
		（同步可以理解为，一条require命令如果不完全执行完，是不会继续执行后面的代码。因为调用一个模块需要加载文件、读取文件、执行代码等步骤，一般加载、读取文件所需时间比执行文件所需时间多，且前者为硬盘缓存等的读写，后者为CPU的执行，CPU要执行文件就必须等待读写的完成）
	</p>
	<h2>缺点</h2>
	<p>
		对于服务器端，本地加载模块基本上不需要考虑速度，但对于客户端，由于commonJS是以<b>同步机制</b>加载模块，容易造成资源加载阻塞的现象（浏览器假死）。
	</p>

	<h3>
		参考文献
	</h3>
	<p>
		[1]wikipedia CommonJS https://en.wikipedia.org/wiki/CommonJS
		[2]阮一峰 CommonJS规范 http://javascript.ruanyifeng.com/nodejs/module.html
	</p>
</body>
</html>